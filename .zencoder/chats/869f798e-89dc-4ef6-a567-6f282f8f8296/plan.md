# Feature development workflow

---

## Workflow Steps

### [x] Step: Requirements

Your job is to generate a Product Requirements Document based on the feature description,

First, analyze the provided feature definition and determine unclear aspects. For unclear aspects: - Make informed guesses based on context and industry standards - Only mark with [NEEDS CLARIFICATION: specific question] if: - The choice significantly impacts feature scope or user experience - Multiple reasonable interpretations exist with different implications - No reasonable default exists - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details

Ask up to 5 most priority clarifications to the user. Then, create the document following this template:

```
# Feature Specification: [FEATURE NAME]


## User Stories*


### User Story 1 - [Brief Title]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

## Requirements*

## Success Criteria*

```

Save the PRD into `c:\Users\david\Desktop\synk\synk-web\.zencoder\chats\869f798e-89dc-4ef6-a567-6f282f8f8296/requirements.md`.

### [x] Step: Technical Specification

Based on the PRD in `c:\Users\david\Desktop\synk\synk-web\.zencoder\chats\869f798e-89dc-4ef6-a567-6f282f8f8296/requirements.md`, create a detailed technical specification to be used by a coding agent to implement the feature. Follow this template:

```
# Technical Specification: [FEATURE]

## Technical Context
Language/Version, primary dependencies, etc

## Technical Implementation Brief

Summarize key technical decisions for implementing the feature. Make sure they take into account the existing code as much as possible.

## Source Code Structure

## Contracts

Define addition or changes in data models, DB schemas, APIs, code interfaces etc

## Delivery Phases

Define several incremental deliverables for the feature. Each should be a minimal viable product testable end-to-end.

## Verification Strategy

Define how the coding agent can verify each deliverable it creates. Provide instructions for the agent to perform the verification using available tools (lint/test commands, bash commands) and create helper scripts and tools for more complex result verification.
The verification for each deliverable should be executable by a coding agent using built-in capabilities (lint and test commands from the project, bash commands), pre-generated helper scripts or MCP servers. Research and add to the spec:

- MCP servers that should be installed to help the agent with the verification

- helper scripts that need to be generated in the first phases of the plan to verify complex scenarios that can't be covered by the tests in the project's test framework(s)

- any sample input artifact(s) that are required for verification. Note if these artifacts can be a) generated by the agent; b) discovered by the agent on line; c) must be provided by the user.
```

Save the spec to `c:\Users\david\Desktop\synk\synk-web\.zencoder\chats\869f798e-89dc-4ef6-a567-6f282f8f8296/spec.md`.

### [x] Step: Implementation Plan

Based on the technical spec in `c:\Users\david\Desktop\synk\synk-web\.zencoder\chats\869f798e-89dc-4ef6-a567-6f282f8f8296/spec.md`, create a detailed task plan and update `c:\Users\david\Desktop\synk\synk-web\.zencoder\chats\869f798e-89dc-4ef6-a567-6f282f8f8296/plan.md`. Each task should have task definition, references to contracts to be used/implemented, deliverable definition and verification instructions.

---

## Implementation Tasks

### [ ] Step: Create Helper Test Script

**Task**: Create `test-email-verification.html` for manual testing without real signups.

**Contracts**: None

**Implementation**:
- Create test page with UI to simulate verification flow
- Mock sessionStorage with test email
- Test verify-email page UI without actual signup
- Add detailed console logging

**Deliverable**: `test-email-verification.html` file that can be opened directly in browser

**Verification**:
- Open file in browser
- Verify test controls work
- Check console shows detailed logs

---

### [ ] Step: Create Email Verification Page

**Task**: Create `verify-email.html` with matching design system and resend functionality.

**Contracts**: 
- SessionStorage keys: `pending_verification_email`, `last_resend_time`
- Design matches `css/auth.css` styling

**Implementation**:
1. Create new HTML file based on `signup.html` structure
2. Add cosmic background matching auth pages
3. Display email address from sessionStorage
4. Add resend email button
5. Implement 60-second cooldown timer with countdown display
6. Add success/error message containers
7. Style to match existing auth.css theme

**Deliverable**: `verify-email.html` with complete UI and countdown timer

**Verification**:
- Load page directly in browser
- Open console and set: `sessionStorage.setItem('pending_verification_email', 'test@example.com')`
- Refresh page, verify email displays
- Check UI matches auth pages design
- Verify countdown timer displays when resend is clicked

---

### [ ] Step: Add Verification Page Styles

**Task**: Add CSS styles for verification page to `css/auth.css`.

**Contracts**: 
- Design system: dark theme, orange gradients, Inter font
- Matches existing auth page components

**Implementation**:
1. Add `.verification-page` styles
2. Add `.verification-icon` styles for email icon/graphic
3. Add `.verification-message` styles
4. Add `.resend-section` styles for button and timer
5. Add `.countdown-timer` styles
6. Ensure mobile responsive

**Deliverable**: Updated `css/auth.css` with verification page styles

**Verification**:
- Load verify-email.html
- Verify visual consistency with login/signup pages
- Test on mobile viewport (375px width)
- Check all elements are properly styled

---

### [ ] Step: Create Email Confirmation Handler

**Task**: Create `js/email-confirmation.js` to handle confirmation link callbacks.

**Contracts**:
- URL hash format: `#access_token=TOKEN&type=signup` or `#error=ERROR`
- Redirect to pricing page on success

**Implementation**:
1. Create new JS file
2. Parse URL hash on page load
3. Check for `access_token` parameter
4. If token exists, validate user session with Supabase
5. On success, clear sessionStorage and redirect to `/pricing`
6. If error parameter exists, display error message
7. Handle edge cases (expired token, invalid format)
8. Add loading state during token exchange

**Deliverable**: `js/email-confirmation.js` script

**Verification**:
- Create test URL: `verify-email.html#access_token=test123&type=signup`
- Open URL, check console logs token parsing
- Verify error handling for malformed URLs
- Check loading states display correctly

---

### [ ] Step: Add Resend Email Method to Auth Manager

**Task**: Add `resendVerificationEmail()` method to `js/supabase-auth-manager.js`.

**Contracts**:
- Method signature: `async resendVerificationEmail(email)`
- Returns: `{success: boolean, error?: string}`
- Uses Supabase `auth.resend()` API

**Implementation**:
1. Open `js/supabase-auth-manager.js`
2. Add new method after `signup()` method
3. Use Supabase client: `supabaseClient.auth.resend({type: 'signup', email})`
4. Handle success/error responses
5. Add console logging for debugging
6. Return standardized response object

**Deliverable**: Updated `js/supabase-auth-manager.js` with resend method

**Verification**:
- Open browser console on any page
- Run: `await window.authManager.resendVerificationEmail('test@example.com')`
- Check console for success/error logs
- Verify method returns correct response format

---

### [ ] Step: Update Signup Flow to Handle Verification

**Task**: Modify `signup.html` to check for `requiresEmailVerification` and redirect accordingly.

**Contracts**:
- Backend response: `{success: true, requiresEmailVerification: true}`
- SessionStorage: Store email as `pending_verification_email`

**Implementation**:
1. Open `signup.html` inline script (lines 132-182)
2. After successful backend response, check `data.requiresEmailVerification`
3. If true:
   - Store email in sessionStorage: `sessionStorage.setItem('pending_verification_email', email)`
   - Show success message: "Account created! Check your email to verify."
   - Redirect to `verify-email.html` after 1.5 seconds
4. If false (legacy behavior):
   - Keep existing redirect to `onboarding.html`

**Deliverable**: Updated `signup.html` with verification redirect logic

**Verification**:
- Mock backend response to return `requiresEmailVerification: true`
- Complete signup form
- Verify redirect goes to verify-email.html
- Check sessionStorage contains email
- Verify success message mentions email verification

---

### [ ] Step: Wire Up Resend Button on Verification Page

**Task**: Connect resend button in `verify-email.html` to auth manager method.

**Contracts**:
- Cooldown: 60 seconds between resends
- SessionStorage: `last_resend_time` timestamp
- Success/error messages displayed

**Implementation**:
1. Open `verify-email.html`
2. Add inline script or external script reference
3. Wait for auth manager to initialize
4. On resend button click:
   - Check last_resend_time in sessionStorage
   - If < 60 seconds ago, show countdown and disable button
   - If >= 60 seconds, call `authManager.resendVerificationEmail(email)`
   - Update last_resend_time
   - Start countdown timer
5. Update countdown every second
6. Display success/error messages

**Deliverable**: Functional resend button with countdown

**Verification**:
- Load verify-email.html with email in sessionStorage
- Click resend button
- Verify button disables and shows countdown
- Wait 60 seconds, verify button re-enables
- Check console for resend API call
- Test multiple rapid clicks (should be blocked by cooldown)

---

### [ ] Step: Add Confirmation Handler to Verify Email Page

**Task**: Include email confirmation handler script in `verify-email.html`.

**Contracts**:
- Script: `js/email-confirmation.js`
- Handles redirect from email click

**Implementation**:
1. Open `verify-email.html`
2. Add script tag before closing body: `<script src="js/email-confirmation.js"></script>`
3. Ensure script loads after Supabase library
4. Test URL hash handling

**Deliverable**: verify-email.html with confirmation handler loaded

**Verification**:
- Open: `verify-email.html#access_token=test&type=signup`
- Check console logs show hash parsing
- Verify handler attempts to process token
- Confirm error handling for invalid tokens

---

### [ ] Step: Add Confirmation Handler to Pricing Page

**Task**: Include email confirmation handler in `pricing.html` (redirect target).

**Contracts**:
- Script: `js/email-confirmation.js`
- Silently handles confirmation, shows success message

**Implementation**:
1. Open `pricing.html`
2. Add script tag: `<script src="js/email-confirmation.js"></script>`
3. Ensure confirmation handler runs on page load
4. Add success banner/message for confirmed users

**Deliverable**: pricing.html handles confirmation redirects

**Verification**:
- Simulate confirmation URL: `pricing.html#access_token=TOKEN`
- Verify handler processes token
- Check success message appears
- Confirm clean URL (hash removed after processing)

---

### [ ] Step: Backend Configuration Instructions

**Task**: Document backend changes needed for email verification.

**Contracts**: Backend API response contract from spec.md

**Implementation**:
- Document is already created in spec.md
- Extract backend instructions section
- Format for easy copy-paste
- Include Supabase Admin SDK example

**Deliverable**: Clear instructions for backend update

**Verification**:
- Read instructions
- Verify all code examples are correct
- Check Supabase Admin SDK syntax

---

### [ ] Step: Supabase Dashboard Configuration

**Task**: Enable email confirmation in Supabase dashboard and configure redirect URLs.

**Contracts**:
- Email confirmations: Enabled
- Redirect URL: pricing page

**Implementation** (User will do this):
1. Go to Supabase Dashboard → Project Settings → Authentication
2. Scroll to "Email" section
3. Enable "Enable email confirmations"
4. Under "Site URL", enter: production domain
5. Under "Redirect URLs", add:
   - `https://[domain]/pricing`
   - `https://[domain]/**` (wildcard)
6. Save changes
7. Test confirmation email template

**Deliverable**: Supabase configured for email verification

**Verification**:
- Create test user via Supabase dashboard
- Check "Email Confirmed" status is false
- Verify confirmation email is sent
- Click link, verify redirect works

---

### [ ] Step: Test Complete Signup Flow

**Task**: End-to-end test of signup → verify → login flow.

**Contracts**: All previous contracts working together

**Implementation**:
1. Open signup page
2. Create new account with real email
3. Verify redirect to verify-email.html
4. Check inbox for confirmation email
5. Click confirmation link
6. Verify redirect to pricing page
7. Check user session is established
8. Test authenticated features work

**Deliverable**: Working end-to-end flow

**Verification**:
- Complete flow with 3 different email addresses
- Test on Chrome, Firefox, Safari
- Verify no console errors
- Confirm all redirects work correctly
- Check user can access authenticated pages

---

### [ ] Step: Test Resend Email Functionality

**Task**: Test resend button with cooldown timer.

**Contracts**: 60-second cooldown, new email sent

**Implementation**:
1. Signup with new email
2. On verify-email page, wait 5 seconds
3. Click resend button
4. Verify countdown starts at 60
5. Verify button is disabled
6. Wait for countdown to reach 0
7. Verify button re-enables
8. Click again, verify new email arrives
9. Test rapid clicks (should be blocked)

**Deliverable**: Verified resend functionality

**Verification**:
- Countdown timer updates every second
- Button disables during cooldown
- New email arrives in inbox after resend
- Multiple rapid clicks don't send multiple emails
- Console shows appropriate logs

---

### [ ] Step: Test Error Scenarios

**Task**: Test edge cases and error handling.

**Contracts**: User-friendly error messages for all failure modes

**Implementation**:
1. Test expired confirmation link (wait 24+ hours or use old link)
2. Test invalid confirmation token (manually edit URL)
3. Test accessing verify-email.html directly (no email in sessionStorage)
4. Test duplicate email signup
5. Test resend with invalid email
6. Test network failures (offline mode)
7. Verify all errors show user-friendly messages

**Deliverable**: Robust error handling

**Verification**:
- Each error scenario displays appropriate message
- No console errors crash the app
- User can recover from errors
- Links to support/help are provided

---

### [ ] Step: Mobile Responsive Testing

**Task**: Test all new pages on mobile devices.

**Contracts**: Responsive design on 375px+ width

**Implementation**:
1. Open DevTools → Device Toolbar
2. Test verify-email.html on:
   - iPhone SE (375px)
   - iPhone 12 (390px)
   - iPad (768px)
3. Verify all text is readable
4. Check buttons are tap-friendly (44px+ height)
5. Test countdown timer visibility
6. Verify no horizontal scroll
7. Test landscape orientation

**Deliverable**: Mobile-optimized experience

**Verification**:
- All pages load correctly on mobile
- No layout breaks or overlaps
- Text is readable without zooming
- Buttons are easily tappable
- Forms work correctly on mobile keyboards

---

### [ ] Step: Final Integration Test

**Task**: Complete final testing and verify all requirements met.

**Contracts**: All requirements from requirements.md

**Implementation**:
1. Review requirements.md success criteria
2. Test each criterion systematically
3. Document any issues found
4. Fix remaining bugs
5. Verify browser compatibility (Chrome, Firefox, Safari, Edge)
6. Check performance (page load times)
7. Review console for any warnings/errors
8. Test with real email addresses

**Deliverable**: Production-ready email verification feature

**Verification**:
- [ ] 100% of signups redirect to verification page
- [ ] Verification emails arrive within 5 seconds
- [ ] Confirmation link redirects to pricing page
- [ ] Resend button works with 60-second cooldown
- [ ] Unverified users cannot access authenticated features
- [ ] All error scenarios handled gracefully
- [ ] Design matches existing site
- [ ] Works on all target browsers
- [ ] Mobile responsive
- [ ] No console errors
